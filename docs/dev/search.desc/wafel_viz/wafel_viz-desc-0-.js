searchState.loadedDescShard("wafel_viz", 0, "Defines the projection and view matrices for a scene.\nA 4x4 square matrix.\nTriangles with this transparency mode will be rendered …\nA hint for how to render a triangle with transparency, …\nA set of two coordinates which may be interpreted as a …\nA set of three coordinates which may be interpreted as a …\nA set of four coordinates which may be interpreted as a …\nTriangles with this transparency mode are only visible if …\nThe adjugate of this matrix, i.e. the transpose of the …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a statically sized array of its …\nInterpret <code>self</code> as a slice of the component (column) vectors\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a statically sized array of its …\nInterpret <code>self</code> as a slice of the component (column) vectors\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nIf the 3x3 left upper block of <code>self</code> is a rotation, return …\nIf <code>self</code> represents an affine transformation, return its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a rotation matrix given a bivector which defines …\nAngles are applied in the order roll -&gt; pitch -&gt; yaw\nCreate a 2d point from a homogeneous 2d <em>point</em>, performing …\nCreate a 3d point from a homogeneous 3d <em>point</em>, performing …\nCreate a 2d vector from homogeneous 2d <em>vector</em>, which simply\nCreate a 3d vector from homogeneous 2d <em>vector</em>, which simply\nAssumes homogeneous 3d coordinates.\nFull 4d nonuniform scaling matrix.\nCreate a new rotation matrix from a rotation around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nAssumes homogeneous 3d coordinates.\nFull 4d diagonal matrix.\nAssumes homogeneous 3d coordinates.\nThe geometric product of this and another vector, which is …\nThe geometric product of this and another vector, which is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a homogeneous 2d <em>point</em> from this vector interpreted …\nCreate a homogeneous 3d <em>point</em> from this vector interpreted …\nCreate a homogeneous 2d <em>vector</em> from this vector, meaning …\nCreate a homogeneous 3d <em>vector</em> from this vector, meaning …\nIf self represents an <code>Isometry3</code> (i.e. self is a product of …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nMoves the camera to the given position and faces it toward …\nConstructs a ‘look-at’ matrix from an eye position, a …\nConstructs a ‘look-at’ matrix from an eye position, a …\nMoves the camera to the given position and faces it toward …\nCreates a new camera with the given projection and view …\nNormalize <code>self</code> in-place by interpreting it as a …\nNormalize <code>self</code> in-place by interpreting it as a …\nNormalize <code>self</code> by interpreting it as a homogeneous point, …\nNormalize <code>self</code> by interpreting it as a homogeneous point, …\nCreates an orthographic camera, which by default looks …\nCreates a perspective camera, which by default looks from …\nThe projection matrix from view space to NDC.\nRotate the camera’s facing angle without changing its …\nSets the camera, which determines the projection and view …\nSets the position and size of the viewport on the window, …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nTransform a Vec3 by self, interpreting it as a point.\nTransform a Vec3 by self, interpreting it as a vector.\nTranslate the camera’s position.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nTruncate <code>self</code> to a matrix consisting of the 3x3 left upper …\nConvert <code>self</code> into a Vec2 by simply removing its <code>z</code> …\nConvert <code>self</code> into a Vec3 by simply removing its <code>w</code> …\nThe view matrix from world space to view space.\nThe wedge (aka exterior) product of two vectors.\nThe wedge (aka exterior) product of two vectors.\nSets a hint for how to render a triangle with …")